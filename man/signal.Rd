% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/signal.R
\docType{data}
\name{signal}
\alias{signal}
\alias{value}
\alias{signal_done}
\alias{signal_todo}
\alias{signal_oops}
\alias{signal_info}
\alias{signal_rule}
\alias{add_color}
\alias{add_style}
\alias{print.mv_style}
\alias{$.mv_style}
\alias{has_style}
\alias{rm_style}
\title{Signal Feedback to the Console UI}
\usage{
value(x)

signal_done(...)

signal_todo(...)

signal_oops(...)

signal_info(...)

signal_rule(text = "", line_col = NULL, lty = c("single", "double"))

add_color(x, col)

add_style

\method{print}{mv_style}(x, ...)

\method{$}{mv_style}(x, y)

has_style(x)

rm_style(x)
}
\arguments{
\item{x}{Character. A string to report to the UI or to add a style/color.}

\item{...}{Elements passed directly to \code{\link[=cat]{cat()}}.}

\item{text}{\code{character(1)}. String added at the left margin
of the horizontal rule.}

\item{line_col}{See \code{col}.}

\item{lty}{\code{character(1)}. Either "single" or "double" line type (matched).}

\item{col}{Color (or style) for the text (or line). Currently one of:
\itemize{
\item red
\item green
\item yellow
\item blue
\item magenta
\item cyan
\item black
\item white
\item grey
\item bold
\item italic
\item underline
\item inverse
\item strikethrough
}}

\item{y}{A coloring function, i.e. an element the \code{add_style} object,
see the \code{col} argument.}
}
\description{
Similar to \verb{usethis::ui_*()} function suite but does not require
importing the \pkg{usethis}, \pkg{crayon}, or \pkg{cli} packages.
All \verb{signal_*()} functions can be silenced by
setting \code{options(signal.quiet = TRUE)}.
}
\section{Functions}{
\itemize{
\item \code{value()}: Signal a value to the UI. Similar to \code{\link[usethis:ui]{usethis::ui_value()}}.
Each element of \code{x} becomes an entry in a comma separated list
and a \code{blue} color is added.

\item \code{signal_done()}: Signal a completed task to the UI. Similar to \code{\link[usethis:ui]{usethis::ui_done()}}.

\item \code{signal_todo()}: Signal a to-do task to the UI. Similar to \code{\link[usethis:ui]{usethis::ui_todo()}}.

\item \code{signal_oops()}: Signal oops error to the UI. Similar to \code{\link[usethis:ui]{usethis::ui_oops()}}.

\item \code{signal_info()}: Signal info to the UI. Similar to \code{\link[usethis:ui]{usethis::ui_info()}}.

\item \code{signal_rule()}: Make a rule with left aligned text. Similar to \code{\link[cli:rule]{cli::rule()}}.

\item \code{add_color()}: Add a color or style to a string. Similar to \code{\link[crayon:crayon]{crayon::crayon()}}.

\item \code{add_style}: An alternative syntax. A list object where each
element is a color/style function wrapping around \code{add_color()} and
each element determines the \code{col} argument. See examples.

\item \code{print(mv_style)}: Functions in the \code{apply_style} object have their
own class, which allows for the special S3 print method and the chaining
in the examples below.

\item \code{$}: Easily chain styles with \code{$} S3 method.

\item \code{has_style()}: Logical. Test if string contains ANSI styles/colors.

\item \code{rm_style()}: Remove a color or style from character strings.

}}
\examples{
n <- 4
cat("You need this many bikes:", value(n + 1))

# value() collapses lengths by sep = ", "
value(names(mtcars))

# signal_done()
signal_done("Tests have passed!")

# easily construct complex messages
signal_done("The 'LETTERS' vector has", value(length(LETTERS)), "elements")

# add a horizontal rule
signal_rule()

signal_rule("Header", line_col = "green", lty = "double")

cat(add_color("Hello world!", "blue"))

# Combined with signal_*() functions
signal_oops("You shall", add_color("not", "red"), "pass!")

# colors and styles available via add_style()
add_style

# These are equivalent
cat(add_style$blue("Hello world!"))
cat(add_color("Hello world!", "blue"))

# Combine styles
red <- add_style$red("This is red")
string <- c(red, "and this is not")
cat(string)

# Combine styles
blue <- add_style$blue("blue")
red  <- add_style$red("red")
string <- add_style$bold(c(blue, red, "nothing"))
cat(string)

# chain styles via `$`
cat(add_style$bold("Success"))
cat(add_style$bold$green("Success"))
cat(add_style$bold$green$italic("Success"))
cat(add_style$bold$green$italic$red("Success"))

# potential typos are trapped
\dontrun{
cat(add_style$bold$greeen$italic("Success"))
}

# check for ANSI styling
has_style(add_style$green("Hello world!"))
has_style(add_style$italic("Hello world!"))

# remove ANSI styling
cat(rm_style(add_style$green("Hello world!")))
cat(rm_style(add_style$italic$cyan("Hello world!")))

}
\keyword{datasets}
