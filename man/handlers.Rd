% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/handlers.R
\name{handlers}
\alias{handlers}
\alias{be_safe}
\alias{be_quiet}
\alias{be_hard}
\title{Handle and Capture Side Effects}
\usage{
be_safe(.f, otherwise = NULL)

be_quiet(.f)

be_hard(.f, ...)
}
\arguments{
\item{.f}{A function to capture and handle in a
user controlled manner.}

\item{otherwise}{The value of \code{result} in the event of an error.}

\item{...}{Named arguments to be hard-coded as key-value pairs.}
}
\value{
\code{\link[=be_safe]{be_safe()}}: a list containing:
\itemize{
\item result: if \code{NULL} there was an error, see \code{error}.
\item error: if \code{NULL} no errors were encountered, see \code{result}.
}

\code{\link[=be_quiet]{be_quiet()}}: a list containing:
\itemize{
\item result: the result of the evaluated expression.
\item output: any output that was captured during evaluation.
\item warnings: any warnings that were encountered during evaluation.
\item messages: any messages that were triggered during evaluation.
}

\code{\link[=be_hard]{be_hard()}}: a function with new hard-coded arguments.
}
\description{
Wrappers to capture side effects and silence function output.
This can be particularly useful for instances where
you know a function may generate a warning/error,
but do not want to terminate any higher-level processes.
Downstream code can then trap the returned object accordingly
because the output is in an expected structure.
Note that \code{\link[=be_hard]{be_hard()}} is not a simple drop-in replacement
for \code{\link[purrr:partial]{purrr::partial()}} as it does \emph{not} support quasi-quotation,
but should be a sufficient replacement in most cases.
}
\section{Functions}{
\itemize{
\item \code{be_safe()}: Roll through \code{\link[=stop]{stop()}} or \code{\link[usethis:ui]{usethis::ui_stop()}} conditions.

\item \code{be_quiet()}: Be quiet! ... always contains a \code{result}.

\item \code{be_hard()}: Be hard! ... coded for specified arguments.

}}
\section{purrr analogues}{

\tabular{ll}{
\pkg{helpr}  \tab \pkg{purrr} \cr
\code{\link[=be_safe]{be_safe()}}  \tab \code{\link[purrr:safely]{purrr::safely()}} \cr
\code{\link[=be_quiet]{be_quiet()}} \tab \code{\link[purrr:quietly]{purrr::quietly()}} \cr
\code{\link[=be_hard]{be_hard()}}  \tab \code{\link[purrr:partial]{purrr::partial()}} \cr
}
}

\examples{
# be safe
safelog <- be_safe(log2)
safelog("a")
safelog("foo" + 10)
safelog(32)

# be quiet
# create a chatty function:
f <- function(x) {
  message("This is a message.")
  message("This is a second message.")
  warning("This is a warning!")
  warning("This is a second warning!")
  cat("Multiplying pi * x^2:\n")
  pi * x^2
}
f2 <- be_quiet(f)
f2(5)

# be hard-coded
vec <- rnorm(50)
navec <- c(NA_real_, vec)
q2 <- be_hard(quantile, probs = c(0.025, 0.975), na.rm = TRUE)

# `be_hard` has a special S3 print method
q2

quantile(vec, probs = c(0.025, 0.975))

q2(vec)

quantile(navec, probs = c(0.025, 0.975), na.rm = TRUE)

q2(navec)
}
